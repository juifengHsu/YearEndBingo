<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>尾牙賓果系統（開發版） v2.0</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 16px; }
    #board { display: grid; grid-template-columns: repeat(5, 56px); gap: 6px; margin-bottom: 12px; }
    .cell { width:56px; height:56px; display:flex; align-items:center; justify-content:center; border:1px solid #ccc; border-radius:6px; background:#fff; cursor:pointer; user-select:none; }
    .cell.locked { background:#eee; cursor:default; }
    #controls { margin-bottom: 12px; }
    button { padding:8px 12px; margin-right:8px; }
    #history { margin-top:12px; }
    #adminPanel { display:none; border:1px dashed #666; padding:12px; margin-top:12px; background:#fafafa; }
    #topLeft { position:fixed; left:8px; top:8px; width:80px; height:80px; opacity:0.02; z-index:9999; }
    .badge { display:inline-block; padding:4px 8px; background:#eee; border-radius:12px; margin-right:6px; }
    #log { max-height:160px; overflow:auto; background:#111; color:#0f0; padding:8px; font-size:12px; border-radius:6px; }
    input[type="text"]{ padding:6px; }
    #version { font-size:12px; color:#666; margin-left:8px; }
  </style>
</head>
<body>

  <div id="topLeft" title="管理入口"></div>

  <h3>尾牙賓果系統（開發版） <span id="versionLabel">v2.0</span></h3>

  <div id="status">
    <span class="badge" id="uidBadge">UID: -</span>
    <span class="badge" id="onlineBadge">狀態: -</span>
    <span class="badge" id="rollingBadge">isRolling: -</span>
    <span class="badge" id="luckyBadge">luckyUser: -</span>
    <span id="version" title="前端版號">版號: <strong id="versionText">v2.0</strong></span>
  </div>

  <div id="controls">
    <button id="genBtn">隨機產生盤面</button>
    <button id="saveBtn">保存盤面</button>
    <button id="lockBtn">鎖定盤面 (locked=true)</button>
    <button id="refreshBtn">重新載入我的資料</button>
    <span style="margin-left:12px">姓名: <input id="nameInput" type="text" placeholder="輸入姓名" /></span>
  </div>

  <div id="board"></div>

  <div>
    <strong>已開號碼 (history)</strong>
    <div id="history"></div>
  </div>

  <div id="pendingArea" style="margin-top:12px;">
    <strong>若你為幸運兒，請在此提交號碼</strong>
    <div>
      <input id="pendingNumber" type="number" min="1" max="75" placeholder="輸入號碼 1~75" />
      <button id="submitPending">提交號碼</button>
    </div>
  </div>

  <div id="adminPanel">
    <h4>管理面板（開發用）</h4>
    <div>
      <button id="drawNumberBtn">隨機抽號（isRolling）</button>
      <button id="pickLuckyBtn">抽幸運兒（篩選 locked & min maxConsecutive）</button>
      <button id="resetBtn">重置遊戲（雙重確認）</button>
    </div>
    <div style="margin-top:8px;">
      <strong>候選名單（locked & lowest maxConsecutive）</strong>
      <div id="candidates"></div>
    </div>
  </div>

  <h4>系統日誌</h4>
  <div id="log"></div>

  <!-- Firebase v9 modular SDK -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-auth.js";
    import {
      getFirestore, doc, setDoc, getDoc, runTransaction, onSnapshot,
      updateDoc, arrayUnion, arrayRemove, serverTimestamp, collection, addDoc
    } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore.js";

    // ====== TODO: 填入你的 Firebase config ======
    const firebaseConfig = {
      apiKey: "YOUR_API_KEY",
      authDomain: "YOUR_AUTH_DOMAIN",
      projectId: "YOUR_PROJECT_ID",
      // ...
    };
    // ==========================================

    // Frontend version
    const VERSION = 'v2.0';

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    // UI elements
    const uidBadge = document.getElementById('uidBadge');
    const onlineBadge = document.getElementById('onlineBadge');
    const rollingBadge = document.getElementById('rollingBadge');
    const luckyBadge = document.getElementById('luckyBadge');
    const boardEl = document.getElementById('board');
    const genBtn = document.getElementById('genBtn');
    const saveBtn = document.getElementById('saveBtn');
    const lockBtn = document.getElementById('lockBtn');
    const refreshBtn = document.getElementById('refreshBtn');
    const nameInput = document.getElementById('nameInput');
    const historyEl = document.getElementById('history');
    const pendingNumber = document.getElementById('pendingNumber');
    const submitPending = document.getElementById('submitPending');
    const logEl = document.getElementById('log');
    const topLeft = document.getElementById('topLeft');
    const adminPanel = document.getElementById('adminPanel');
    const drawNumberBtn = document.getElementById('drawNumberBtn');
    const pickLuckyBtn = document.getElementById('pickLuckyBtn');
    const resetBtn = document.getElementById('resetBtn');
    const candidatesEl = document.getElementById('candidates');
    const versionText = document.getElementById('versionText');

    // show version in UI
    versionText.innerText = VERSION;
    document.title = `尾牙賓果系統（開發版） ${VERSION}`;
    document.getElementById('versionLabel').innerText = VERSION;

    // state
    let currentUID = null;
    let myPlayerDocRef = null;
    let myBoard = []; // 25 numbers
    let locked = false;
    let heartbeatTimer = null;
    let clickCount = 0;
    let lastClickTime = 0;

    // helper log
    function log(msg) {
      const t = new Date().toLocaleTimeString();
      logEl.innerText = `[${t}] ${msg}\n` + logEl.innerText;
    }

    // anonymous sign-in
    signInAnonymously(auth).catch(err => {
      log('匿名登入失敗: ' + err.message);
    });

    onAuthStateChanged(auth, async user => {
      if (user) {
        currentUID = user.uid;
        uidBadge.innerText = 'UID: ' + currentUID;
        myPlayerDocRef = doc(db, 'players', currentUID);
        log('已登入 (匿名) uid=' + currentUID);
        await loadOrCreatePlayer();
        startHeartbeat();
        startListeners();
      } else {
        uidBadge.innerText = 'UID: -';
      }
    });

    // UI: generate random board (25 unique numbers 1..75)
    function generateBoard() {
      const pool = Array.from({length:75}, (_,i)=>i+1);
      for (let i = pool.length-1; i>0; i--) {
        const j = Math.floor(Math.random()*(i+1));
        [pool[i], pool[j]] = [pool[j], pool[i]];
      }
      myBoard = pool.slice(0,25);
      renderBoard();
    }

    function renderBoard() {
      boardEl.innerHTML = '';
      for (let i=0;i<25;i++){
        const n = myBoard[i] ?? '';
        const cell = document.createElement('div');
        cell.className = 'cell' + (locked ? ' locked' : '');
        cell.innerText = n;
        boardEl.appendChild(cell);
      }
    }

    genBtn.addEventListener('click', () => {
      if (locked) { alert('盤面已鎖定，無法再隨機換號'); return; }
      generateBoard();
    });

    // load or create player doc
    async function loadOrCreatePlayer() {
      try {
        const snap = await getDoc(myPlayerDocRef);
        if (snap.exists()) {
          const data = snap.data();
          nameInput.value = data.name || '';
          myBoard = data.board || [];
          locked = !!data.locked;
          renderBoard();
          log('載入玩家資料');
        } else {
          await setDoc(myPlayerDocRef, {
            name: '',
            board: [],
            boardStr: '',
            locked: false,
            maxConsecutive: 0,
            lastSeen: serverTimestamp(),
            version: 1,
            clientVersion: VERSION
          });
          log('建立新玩家文件');
        }
      } catch (e) {
        log('載入/建立玩家失敗: ' + e.message);
      }
    }

    refreshBtn.addEventListener('click', loadOrCreatePlayer);

    // save board with Transaction: create board_index/{boardStr} and players/{uid} atomically
    saveBtn.addEventListener('click', async () => {
      if (!currentUID) { alert('尚未登入'); return; }
      if (!myBoard || myBoard.length !== 25) { alert('請先產生完整盤面'); return; }
      const boardStr = myBoard.join(',');
      const boardIndexRef = doc(db, 'board_index', boardStr);
      const playerRef = myPlayerDocRef;

      try {
        await runTransaction(db, async (tx) => {
          const biSnap = await tx.get(boardIndexRef);
          if (biSnap.exists()) {
            throw new Error('盤面重複');
          }
          tx.set(boardIndexRef, { owner: currentUID, createdAt: serverTimestamp(), clientVersion: VERSION });
          tx.set(playerRef, {
            name: nameInput.value || '',
            board: myBoard,
            boardStr: boardStr,
            locked: false,
            maxConsecutive: 0,
            lastSeen: serverTimestamp(),
            version: 1,
            clientVersion: VERSION
          }, { merge: true });
        });
        log('盤面保存成功');
        alert('盤面保存成功');
      } catch (e) {
        log('保存盤面失敗: ' + e.message);
        alert('保存失敗: ' + e.message);
      }
    });

    // lock board (set locked=true) - uses optimistic version increment
    lockBtn.addEventListener('click', async () => {
      if (!currentUID) return;
      try {
        await runTransaction(db, async (tx) => {
          const pSnap = await tx.get(myPlayerDocRef);
          if (!pSnap.exists()) throw new Error('玩家文件不存在');
          const data = pSnap.data();
          const newVersion = (data.version || 1) + 1;
          tx.update(myPlayerDocRef, { locked: true, version: newVersion, clientVersion: VERSION });
        });
        locked = true;
        renderBoard();
        log('盤面已鎖定');
      } catch (e) {
        log('鎖定失敗: ' + e.message);
        alert('鎖定失敗: ' + e.message);
      }
    });

    // heartbeat: update lastSeen every 15s (throttled)
    function startHeartbeat() {
      if (heartbeatTimer) clearInterval(heartbeatTimer);
      const tick = async () => {
        if (!currentUID) return;
        try {
          await updateDoc(myPlayerDocRef, { lastSeen: serverTimestamp(), clientVersion: VERSION });
          onlineBadge.innerText = '狀態: 在線';
        } catch (e) {
          log('heartbeat 寫入失敗: ' + e.message);
        }
      };
      tick();
      heartbeatTimer = setInterval(tick, 15000);
    }

    // listeners: game_state and my player doc
    function startListeners() {
      const gsRef = doc(db, 'game_state', 'current_game');
      onSnapshot(gsRef, snap => {
        if (!snap.exists()) return;
        const data = snap.data();
        rollingBadge.innerText = 'isRolling: ' + (data.isRolling ? 'true' : 'false');
        luckyBadge.innerText = 'luckyUser: ' + (data.luckyUser || '-');
        const history = data.history || [];
        historyEl.innerText = history.join(', ');
        recalcMyMaxConsecutive(history);
      }, err => {
        log('game_state 監聽錯誤: ' + err.message);
      });

      onSnapshot(myPlayerDocRef, snap => {
        if (!snap.exists()) return;
        const data = snap.data();
        nameInput.value = data.name || nameInput.value;
        myBoard = data.board || myBoard;
        locked = !!data.locked;
        renderBoard();
      }, err => {
        log('players 監聽錯誤: ' + err.message);
      });

      const pendingRef = doc(db, 'pending_choices', currentUID);
      onSnapshot(pendingRef, snap => {
        if (!snap.exists()) return;
        const data = snap.data();
        log('pending_choices 收到: ' + JSON.stringify(data));
        alert('管理端已收到你的號碼，等待審核');
      });
    }

    // calculate maxConsecutive for my board given history array
    async function recalcMyMaxConsecutive(history) {
      if (!myBoard || myBoard.length !== 25) return;
      const grid = [];
      for (let r=0;r<5;r++){
        grid[r] = myBoard.slice(r*5, r*5+5);
      }
      const hitSet = new Set(history || []);
      let globalMax = 0;
      for (let r=0;r<5;r++){
        let cur = 0;
        for (let c=0;c<5;c++){
          if (hitSet.has(grid[r][c])) { cur++; globalMax = Math.max(globalMax, cur); }
          else cur = 0;
        }
      }
      for (let c=0;c<5;c++){
        let cur = 0;
        for (let r=0;r<5;r++){
          if (hitSet.has(grid[r][c])) { cur++; globalMax = Math.max(globalMax, cur); }
          else cur = 0;
        }
      }
      let cur = 0;
      for (let i=0;i<5;i++){
        if (hitSet.has(grid[i][i])) { cur++; globalMax = Math.max(globalMax, cur); }
        else cur = 0;
      }
      cur = 0;
      for (let i=0;i<5;i++){
        if (hitSet.has(grid[i][4-i])) { cur++; globalMax = Math.max(globalMax, cur); }
        else cur = 0;
      }

      try {
        await updateDoc(myPlayerDocRef, { maxConsecutive: globalMax, clientVersion: VERSION });
        log('更新 maxConsecutive = ' + globalMax);
      } catch (e) {
        log('更新 maxConsecutive 失敗: ' + e.message);
      }
    }

    // pending_choices submit (player)
    submitPending.addEventListener('click', async () => {
      const num = parseInt(pendingNumber.value);
      if (!num || num < 1 || num > 75) { alert('請輸入 1~75 的號碼'); return; }
      const pendingRef = doc(db, 'pending_choices', currentUID);
      try {
        await setDoc(pendingRef, {
          number: num,
          playerName: nameInput.value || '',
          timestamp: serverTimestamp(),
          clientVersion: VERSION
        });
        log('已提交 pending_choices: ' + num);
        alert('已提交號碼，等待管理端審核');
      } catch (e) {
        log('提交 pending_choices 失敗: ' + e.message);
      }
    });

    // ===== Admin hidden entry (front-end PIN) =====
    topLeft.addEventListener('click', () => {
      const now = Date.now();
      if (now - lastClickTime > 3000) clickCount = 0;
      clickCount++;
      lastClickTime = now;
      if (clickCount >= 5) {
        clickCount = 0;
        const pin = prompt('輸入管理 PIN');
        if (pin === '2025') {
          adminPanel.style.display = 'block';
          log('管理面板已開啟（前端 PIN）');
          loadCandidates();
        } else {
          alert('PIN 錯誤');
        }
      }
    });

    // admin: draw number (isRolling true -> append new number)
    drawNumberBtn.addEventListener('click', async () => {
      const gsRef = doc(db, 'game_state', 'current_game');
      try {
        await updateDoc(gsRef, { isRolling: true, clientVersion: VERSION });
        rollingBadge.innerText = 'isRolling: true';
        log('開始抽號動畫...');
        setTimeout(async () => {
          try {
            await runTransaction(db, async (tx) => {
              const snap = await tx.get(gsRef);
              const data = snap.exists() ? snap.data() : { history: [] };
              const history = data.history || [];
              const pool = [];
              for (let i=1;i<=75;i++) if (!history.includes(i)) pool.push(i);
              if (pool.length === 0) throw new Error('號碼已抽完');
              const pick = pool[Math.floor(Math.random()*pool.length)];
              const newHistory = history.concat([pick]);
              tx.set(gsRef, { history: newHistory, isRolling: false, clientVersion: VERSION }, { merge: true });
              await addDoc(collection(db, 'audit_logs'), {
                action: 'draw_number',
                detail: { number: pick, actor: 'admin', clientVersion: VERSION },
                timestamp: serverTimestamp()
              });
            });
            log('抽號完成');
          } catch (e) {
            log('抽號 Transaction 失敗: ' + e.message);
            await updateDoc(gsRef, { isRolling: false, clientVersion: VERSION });
          }
        }, 2000);
      } catch (e) {
        log('設定 isRolling 失敗: ' + e.message);
      }
    });

    // admin: pick lucky user (locked=true & min maxConsecutive)
    pickLuckyBtn.addEventListener('click', async () => {
      try {
        const playersCol = collection(db, 'players');
        const qSnapPromise = new Promise((resolve, reject) => {
          const unsub = onSnapshot(playersCol, snap => {
            unsub();
            resolve(snap);
          }, err => reject(err));
        });
        const snap = await qSnapPromise;
        const candidates = [];
        snap.forEach(docSnap => {
          const d = docSnap.data();
          if (d.locked) candidates.push({ uid: docSnap.id, name: d.name || '', maxConsecutive: d.maxConsecutive || 0 });
        });
        candidates.sort((a,b) => a.maxConsecutive - b.maxConsecutive);
        const top15 = candidates.slice(0,15);
        candidatesEl.innerText = top15.map(c => `${c.name || c.uid} (maxC:${c.maxConsecutive})`).join('\n');
        if (top15.length === 0) { alert('沒有符合條件的候選人'); return; }
        const pick = top15[Math.floor(Math.random()*top15.length)];
        const gsRef = doc(db, 'game_state', 'current_game');
        await updateDoc(gsRef, { luckyUser: pick.uid, clientVersion: VERSION });
        log('已選出幸運兒: ' + (pick.name || pick.uid));
        alert('已選出幸運兒: ' + (pick.name || pick.uid));
        await addDoc(collection(db, 'audit_logs'), {
          action: 'pick_lucky',
          detail: { uid: pick.uid, name: pick.name, clientVersion: VERSION },
          timestamp: serverTimestamp()
        });
      } catch (e) {
        log('抽幸運兒失敗: ' + e.message);
      }
    });

    // admin: reset game (double confirm)
    resetBtn.addEventListener('click', async () => {
      const ok1 = confirm('確認要重置遊戲？此動作會刪除 players, pending_choices, audit_logs 並重置 game_state');
      if (!ok1) return;
      const ok2 = confirm('再次確認：確定要執行重置？');
      if (!ok2) return;
      try {
        const gsRef = doc(db, 'game_state', 'current_game');
        await setDoc(gsRef, { history: [], isRolling: false, luckyUser: '', status: 'waiting', clientVersion: VERSION }, { merge: true });
        await addDoc(collection(db, 'audit_logs'), {
          action: 'reset_game',
          detail: { actor: 'admin', clientVersion: VERSION },
          timestamp: serverTimestamp()
        });
        alert('已重置 game_state（注意：此 demo 未批次刪除所有 documents，請在需要時手動清理）');
        log('執行重置（僅重置 game_state 與寫入 audit_logs）');
      } catch (e) {
        log('重置失敗: ' + e.message);
      }
    });

    // load candidates helper
    async function loadCandidates() {
      try {
        const playersCol = collection(db, 'players');
        const qSnapPromise = new Promise((resolve, reject) => {
          const unsub = onSnapshot(playersCol, snap => {
            unsub();
            resolve(snap);
          }, err => reject(err));
        });
        const snap = await qSnapPromise;
        const candidates = [];
        snap.forEach(docSnap => {
          const d = docSnap.data();
          if (d.locked) candidates.push({ uid: docSnap.id, name: d.name || '', maxConsecutive: d.maxConsecutive || 0 });
        });
        candidates.sort((a,b) => a.maxConsecutive - b.maxConsecutive);
        candidatesEl.innerText = candidates.slice(0,15).map(c => `${c.name || c.uid} (maxC:${c.maxConsecutive})`).join('\n');
      } catch (e) {
        log('載入候選人失敗: ' + e.message);
      }
    }

    // initial render
    generateBoard();
    renderBoard();

  </script>
</body>
</html>
